;;global variables

global slice owner_address;
global int owner_public_key;
global int loaded;
global int nextGameId;

;;loads the stored data to global variables
() initialize_globals() impure inline_ref {
  ifnot (null?(loaded)) {
    return ();
  }
  var ds = get_data().begin_parse();
  ;;load data variables here
  owner_address = ds~load_msg_addr();
  owner_public_key = ds~load_uint(256);
  nextGameId = ds~load_uint(32);
  games = slice_empty?(ds) ? new_dict() : ds~load_dict();
  loaded = true;
}


;;returns Matchain owner address
slice get_owner() inline method_id {
  initialize_globals();
  return owner_address;
}

;;store data
() store_data() impure {
  set_data(begin_cell()
    .store_slice(owner_address)
    .store_uint(owner_public_key, 256)
    .store_uint(nextGameId, 32)
    .store_dict(games)
    .end_cell()
  );
}

;;internal
;; Op codes
;; 0 -

() recv_internal(int msg_value, cell in_msg_body_cell, slice in_msg_body) impure {
  var cs = in_msg_body_cell.begin_parse();
  var msg_hash = slice_hash(cs);
  cs~skip_bits(3);
  ;; When bounced do nothing
  var bounced = cs~load_uint(1);
  if (bounced == 1) {
    return ();
  }
  initialize_globals();
  ;; Reading user's address
  slice src_addr_slice = cs~load_msg_addr();
  var (src_wc, src_addr) = parse_std_addr(src_addr_slice);
  var op = in_msg_body~load_in_msg_body_op();
}

;;external
;; Op codes
;; Op 1 - lista  game
;; Return codes
;; 402 - Invalid signature
;; 404 - Unsupported opcode
() recv_external(slice in_msg_body) impure {
  initialize_globals();

  var signature = in_msg_body~load_bits(512);
  var hash = slice_hash(in_msg_body);
  var msg_seq_no = in_msg~load_uint(32);
  var op = in_msg_body~load_uint(32);
  ;; external public
  if(op == 0){ 

  }else{
    ;; Function only owner
    throw_if(403, msg_seq_no != seq_no);
    throw_unless(402, check_signature(hash, signature, owner_public_key));
    accept_message(); ;; complete the tx

    ;; List a game
    if (op == 1) {
      ;;obtain sended msg address 
        var address = in_msg~load_msg_addr(); 
        ;;store in an unsing dict using gameId as index the address
        games = games.udict_set(32, nextGameId , address);
        ;;updates the next gameId
        nextGameId += 1;
    }
    ;; Set owner
    elseif (op == 2) {
      owner_address = in_msg~load_msg_addr();
    }
    ;; Unlist a game
    elseif (op == 3) {
    }
    ;; Self destruct
    elseif (op == 666) {
      var (owner_wc, owner_addr) = parse_std_addr(owner_address);
      send_money(owner_wc, owner_addr, 0, null(), 128 + 32);
    }
    elseif (seq_no == 0) {
      accept_message(); ;; complete the tx
  } else {
      throw(404);
  }
    seq_no += 1;
    store_data();
  } 
}